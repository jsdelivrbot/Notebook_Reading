# 数据库技术

## 一 绪论

### 概念

- 数据
- 信息=数据+数据处理

### 数据库技术历史

人工管理阶段|1950s中期前；

文件系统阶段|1950-60s,mid；进步点：长期保存；相应管理软件；程序与数据独立

数据库系统阶段|1960s,end-；进步点：数据冗余度；数据独立性；数据一致性

### 数据库系统

#### 组成

- 数据库
  - 长期存储|有组织（集成性）|可共享 的数据集合。
- 用户
  - 终端用户
  - 应用程序员
  - 数据库管理员
    - 数据库设计
    - 安全性与完整性定义；权限管理
    - 恢复数据库
- DBMS（软件）
- 硬件

#### 内部体系结构

- 概念模式 Schema:全体数据逻辑结构的抽象表示
- 外模式/子模式：个别用户使用的数据结构和特征（不唯一）
- 内模式：全体数据物理存储结构的描述，但不关心物理位置

二级映像：逻辑和物理独立性

### 数据库管理系统

#### 主要功能

- 数据定义 DDL
- 数据操纵 DManipulationL
- 运行管理
  - 安全性控制
  - 完整性控制
  - 并发控制
  - 数据恢复
- 数据组织存储和管理
  - 数据字典
  - 用户数据
- 建立和维护
- 数据通信
  - 与其它软件系统之间

### 数据模型

- 数据结构
  - 层次 网状 关系
- 数据操作
- 约束条件

#### 信息世界的概念

- 实体 Entity
- 属性 Attribute [椭圆]
  - 分量：某个取值
- 实体型 Entity type： [矩形框]
  - 学生（学号、姓名、性别）
- 实体集 Entity Set
- 键 码 Key：唯一标识一个实体的属性集合
- 域 Domain：属性值的取值范围
- 联系：实体型之间 [菱形]
  - 1:1 班级和班长
  - 1:n 班级和学生
  - m:n 教师和学生

计算机|信息界|关系型
--|--|--
字段|属性|属性
实体|记录|元组
实体集|文件|关系

#### 数据模型分类

模型|名称|数据联系|缺点
--|--|--|--
层次|Hierarchical|树结构|难表示多队多联系
网状|network|图结构|完整性约束弱；独立性差
关系|relational|二维表|存取路径不可见

## 二 关系数据库

### 关系理论

- 基数：域包含的值的个数，用m表示
- 笛卡尔积：n个域之间运算，结果是（元素）n元组的集合
- 关系 $D1\times D2$的任一（实际中只选取有意义的）子集称为定义在D1,D2上的2元关系
  - R(D1,D2)  n=2
  - 关系的目或度 n
  - 关系的基数 r 关系内元组个数
  - 关系头：属性名的集合
  - 关系提：数据内容
- 关系性质
  - 元组不重复
  - 顺序不相干（元组或属性）
  - 同属性的各个属性值，域相同
  - 各个属性，名字相异
  - 每个分量是不可分的数据项：属性原子性
    - 规范化关系的基准

### 关系的码

- 候选码 Candidate key： 属性集
  - 唯一性
  - 最小性
- 主关系键|主码|关键字：选自候选码
  - 主属性：包含在主码内
  - 非主属性：不包含于任何候选码
  - 全码 all-key：所有属性的组合是候选码
- 参照关系 referencing relation
  - R2参照R1:R2的属性C，不是R2主码，是R1主码
  - X为R1的外部关系键|外码

### 关系模型完整性

- 实体完整性 Entity Integrity:主码值均不为空
- 参照完整性 Referential：外码取参照的主码中的值或者控制
- 用户定义完整性：语义要求

### 关系数据库模式

- 关系模式 relation schema: R(U,D,Dom,F)
  - 关系名
  - D 属性集合
  - Dom 属性向域的映像集合
  - 属性间依赖关系
- 关系数据库
  - 型：模式
  - 值：内容

### 关系代数

- 集合运算
  - 并； 差； 笛卡尔积
- 关系概念
  - $t[A_i]$ 元组t相应于属性A_i的一个分量
  - 连接
  - 象集
- 关系运算
  - 选择：按条件选择元组
  - 投影：选择属性列组成新关系
  - 连接：在笛卡尔积上选取满足条件的子集
  - 除法：R(X,Y)÷S(W,Z)
    - W与Y域相同
    - 选取X的某些值x，x对应的各元组中的y集合包含W的全部y值

## 三 SQL

### 数据类型

- NUMERIC(P,[S]) 精度P（总位数） 小数位数S
- CHAR(N) 长度N

### 建表语句和相关约束

```sql
CREATE TABLE S
(SNO CHAR(6) ,
SN VARCHAR(10) UNIQUE,--只允许一个空值
AGE INT CONSTRAINT CONS1 NOT NULL,
SEX CHAR(2) DEFAULT '男', --DEFAULT 默认值
DEPT VARCHAR(20),
PRIMARY KEY(SNO,DEPT));
```

约束名称省略时，系统会自动生成一个。

```sql
CREATE TABLE R
(SNO CHAR(6) CONSTRAINT CONS2 NOT NULL PRIMARY KEY,
SNA CHAR(10) FOREIGN KEY REFERENCES S(SN),
AGE NUMERIC(2,0) CHECK(SCORE>0));--CHECK既能作表约束也可作列约束
```

`从表`：包含外码；`主表`：包含从表所引用的主码。

### 修改删除基本表

ADD方式：增加新列（自动填充NULL值）或完整性约束

```SQL
ALTER TABLE S
ADD (CLASS_NO CHAR(6),
     ADDR CHAR(40));--NOT NULL不可用
```

```sql
ALTER TABLE SC
ADD CONSTRAINT SCORE_CHK
CHECK (SCORE BETWEEN 0 AND 100);
```

ALTER方式：修改某些列

```SQL
ALTER TABLE S
ALTER COLUMN--不能修改列名或减少数据宽度
(SNO CHAR(8) not null);--只能改NULL约束
```

DROP方式：删除完整性约束

```SQL
ALTER TABLE S DROP CONSTRAINT AGE_CHK;
```

删除表：索引随之删除，视图会保留但不可用。

```SQL
DROP TABLE S;
```

### 索引

- 数据库随机检索手段
- 记录关键字与相应地址的对应表
- 作用
  - 加快查询速度
  - 保证行的唯一性
- 聚集索引（没有另建，只是排序）与非聚蔟索引（排列结果另外存储）
  - 一张表只能有一个CLUSTER索引
- 唯一索引：每个索引值对应唯一记录
  - UNIQUE约束:自动建立非聚集的； PRIMARY KEY：建立聚集的
  - 有重复值时不能建立
- 复合索引：基于多个字段

```sql
CREATE [UNIQUE] [CLUSTER] INDEX SCI ON SC(SNO [ASC],CNO[DESC]);
DROP INDEX SC.SCI;
```

### 查询

```sql
SELECT [<all|top n|distinct/*去重*/>]<列名[AS 别名1/*查询时只显示别名*/]>[{,<列名[AS 别名2]>}]
FROM〈表名或视图名〉[{,<表名或视图名>}] [AS 别名3]
[WHERE〈检索条件〉] -- 对元组的限制
[GROUP BY <列名1>[HAVING <条件表达式>]] -- 对聚集后的关系的限制
[ORDER BY <列名2>[ASC|DESC]]; -- 默认升序
```

- 执行过程
  1. 选取满足WHERE的元组
  1. 投影SELECT指定的列，得到结果表
  1. 分组；排序

#### 条件查询

类别|符号|说明
--|--|--
比较运算符|= != > <=|
逻辑运算符|AND OR NOT|
确定范围|BETWEEN AND|闭区间
空值|IS NULL|<属性名>=NULL不合法
字符匹配|<属性名>LIKE<字符串常量>|通配符：%任意长度 _单个字符
确定集合|IN ('C1','C2')|括号即集合

ESCAPE ‘<换码字符>’：自定义转义字符

```SQL
SELECT * FROM T WHERE TN LIKE
 ‘MC\_%’ ESCAPE ‘\’; /*  \ 是转义字符  */
```

#### 常用库函数与分组查询

AVG() SUM() MIN() MAX() COUNT()

```SQL
SELECT COUNT(DISTINCT DEPT) AS DeptNum FROM S;
/* 不计算重复行 */
```

- COUNT(<属性名>) 不计空值
- COUNT(*) 元组个数

#### 结果排序

```SQL
ORDER BY SUM(SCORE) DESC -- 错误
ORDER BY 2 DESC -- '2'代表查询结果的第二列
```

#### 数据表连接

##### JOIN关键字

```SQL
SELECT T.TNO,TN,CNO
FROM T JOIN TC -- 默认INNER JOIN
ON T.TNO=TC.TNO AND T.TN='刘伟'
/*或者*/
SELECT R2.TNO,R2.TN, R1.CNO FROM
(SELECT TNO,CNO FROM TC ) AS R1
INNER JOIN (SELECT TNO ,TN FROM T
WHERE TN='刘伟') AS R2 ON R1.TNO=R2.TNO
```

FROM可以跟SELECT结果

##### 自身连接

```SQL
SELECT X.TN, X.SAL, Y.SAL -- 找出比刘伟工资高的老师
FROM T AS X ,T AS Y -- 同一个表的两个别名
WHERE X.SAL>Y.SAL AND Y.TN=‘刘伟’；
```

#### 嵌套查询

外部查询|父查询 的WHERE子句 包含 嵌套查询|子查询

- 最高255层
- 由内向外处理

```SQL
/* 子查询返回一组值 */
WHERE <> = ANY(子查询)
/* 或者 */WHERE <> IN (子查询)

WHERE SAL > ALL(子查询) -- 等价于子查询选择最大值

 !=ALL(子查询) /*等价于*/ NOT IN (子查询)
```

- 相关子查询：子查询条件中引用父查询表的属性值
- 执行顺序
  - 选取父查询表的第一行，子查询利用此值计算
  - 父查询据子查询结果判断第一行是否满足条件
  - 下一行
- 存在量词 EXIST 返回逻辑值 T/F

### 数据更新

#### 插入

省略列名（此时新纪录必须在每个属性上均有值）

```SQL
INSERT INTO S VALUES(‘s7’,‘郑冬’,‘女’,21,‘计算机’)
```

指定列名（部分列）

```SQL
INSERT INTO SC (SNO,CNO)
VALUES ('s7', 'c1');
```

插入多行（利用子查询的表间复制）

```SQL
INSERT INTO AVGSAL
SELECT DEPT,AVG(SAL) FROM T
GROUP BY DEPT ;
```

#### 修改

```sql
UPDATE <表名>
SET <列名>=<表达式> [,<列名>=<表达式>]
[WHERE <条件>]
```

表达式可以是常量，基于属性的运算，或子查询的结果。

#### 删除

```SQL
DELETE FROM TC  --注意：两个关键字连用
WHERE TNO=(SELECT TNO
FROM T  WHERE TN=‘刘伟’);
```

### 视图

- 记录来自基本表，只有定义被存储。
- 用户可在视图上再定义视图或进行查删改操作
- 作用：
  - 数据保密，限制访问
  - 简化复杂的查询操作
  - 保证外模式与模式的逻辑独立性

#### 定义和删除视图

```SQL
CREATE VIEW <视图名>[(<视图列表>)] AS <子查询>
```

- 视图列表是视图当中的列名，可由子查询中的AS子句给定
- 子查询中ORDER BY子句和 DISTINCT短语禁用

```SQL
DROP VIEW SUB_T;  --删除
```

删除视图后，其导出视图不会删除，但它们已无意义。

#### 视图消解

- View Resolution
- 对视图执行查询时，系统会将数据字典中的视图定义和用户查询结合。

### 数据控制 Data Control Language

#### 权限与角色

概念|授予主体|权限范围
--|--|--
系统权限|数据库管理员|比如，建表
对象权限|基本表或视图创建者|对数据库对象的操作

角色：多种权限的集合；授给用户或其他角色

##### 系统权限授予

```SQL
GRANT <权限>|<角色> [,<权限>|<角色>] -- 如"CREATE TABLE"
TO <用户名>|<角色>|PUBLIC[,<用户名>|<角色>] --public代表全体用户
[WITH ADMIN OPTION] --允许转授
```

##### 对象权限授予

```SQL
GRANT ALL|<权限>[(列名[,列名])][,<权限>]
ON <对象名> -- 基本表或视图
TO <用户名>|<角色>|PUBLIC[,<用户名>|<角色>]
[WITH GRANT OPTION]
```

只有SELECT INSERT UPDATE才需要指定列名

##### 对象权限收回

```SQL
REVOKE SELECT ON C FROM USER1
```

## 四 关系数据库规范化理论

### 第一范式 1NF

每一个分量是不可分的数据项

#### 存在问题

- 数据冗余
- 更新异常 Update Anomalies
- 插入异常 Insertion
- 删除异常

### 数据依赖

关系内部，属性与属性之间的依赖关系

- 多值依赖
- 函数依赖 X→Y
  - X函数确定Y Y函数依赖于X
  - 平凡与非平凡
  - 完全与部分：Y是否依赖于X的真子集
  - 传递与直接
  - 基本性质
    - 投影 扩张 合并 分解

主属性Prime Attribute：包含在任何一个候选码中的属性。

外部码Foreign Key：是另一个关系模式的码。

### 第二范式

非主属性完全依赖于码；仍然存在四种异常

- 2NF规范化
  - 投影分解，不完全依赖的属性，新的关系。
  - 基本原则：一事一地 （一个关系只描述一个实体或联系）

### BC范式

2NF与3NF没有限制主属性对主码的依赖关系

1. 所有非主属性对每一个码都是完全函数依赖
1. 所有主属性，对不包含它的码，完全函数依赖
1. 没有属性完全函数依赖于非码属性组

范式|要点
--|--
2NF|非主属性完全依赖于码
3NF|非主属性不存在传递依赖
BCNF|决定属性组都包含码

- 函数依赖保持性
- 无损连接性

## 五 数据库安全保护

### 数据库安全性

防止非法使用造成数据泄露更改或破坏：控制访问策略

#### 用户标识和鉴定 Identification and Authentication

- 用户名与口令
- 授权表
  - 数据字典当中
  - 用户标识 & 数据对象 & 操作类型
- 授权粒度
  - 关系 记录 属性 数值
    - 存取谓词的操作：DEPT=‘计算机’

|对象|操作类型
--|--|--
模式|内 外 模式|建立 修改 检索
数据|表 属性列|查找 插入 修改 删除

#### 定义视图

#### 数据加密 Data Encryption

替换 | 转换

#### 审计 Audit

监视跟踪有关数据的访问活动 记录位于Audit log

```SQL
AUDIT SELECT, UPDATE ON TABLE_S WHENEVER SUCCESSFULL
NO AUDIT ON TABLE_S
```

### 完整性控制

保护数据正确有效相容

- 按对象粒度分类
  - 列级约束
  - 元组约束
    - 发货量不得超过订货量
  - 关系级
    - 函数依赖：同一关系不同属性间
    - 实体完整性和参照完整性（两个不变性）
    - 统计约束
      - 系主任奖金不得高于该系平均奖金
- 静态约束和动态约束

#### 完整性规则

- 五元组(D,O 用户操作,A 语义约束,C 哪些元组,P)
- 触发条件
  - 立即执行 Immediate Constrains：某一语句完成后
  - 延迟执行 Defferred : 整个事务结束后提交前
- 约束条件
- 违约响应

### 并发控制

#### 事务 Transaction

一组操作序列

```SQL
BEGIN TRANSACTION
COMMIT -- 只有在此之后，事务对数据库造成的变动才对其他事务开放
ROLLBACK
```

- 原子性 Atomic
- 一致性 Consistency：满足完整性约束
- 隔离性 Isolation
- 持续性 Durability

#### 并发操作导致数据的不一致性

- 丢失更新 Lost Update： 更新结果被另一事务覆盖
- 读脏数据 Dirty Read： 读取数据后，数据被回滚
- 不可重读 Unrepeatable Read：核对数据时

#### 控制技术：Lock & Timestamping

- 封锁类型
  - 排他锁 X：其他事务无法加锁
  - 共享锁 S：允许其他事务的查询
- 封锁协议 Loct Protocol
  - 一级：修改前加X锁直到事务结束，读取数据不用加锁
  - 二级：读取数据期间加S锁
  - 三级：事务结束才释放S锁
- 封锁粒度 Lock Granularity
  - 字段 记录 表 数据库
  - 权衡系统开销与并发度
- 新问题
  - 活锁 Live lock：某一事务总轮不到
  - 死锁 Deadlock:双方抢占被对方锁住的数据
    - 一次性加锁所有会用到的数据对象
    - 所有对象有一个封锁顺序

### 数据库恢复

#### 登记日志 logging

- 内容
  - 事务ID
  - 操作类型
  - 操作对象
  - 新值旧值
  - 关键时刻（事务起止回写时间点）
- 原则（避免事务处理半途故障导致不可恢复）
  - 登记按照并行事务执行次序
  - 先写日志，后写数据库

#### 数据转储 data dump

定期将整个数据库复制到多个存储设备

- 海量 与 增量转储（只转储更新过的数据）
- 静态（期间不允许数据存取活动） 与 动态转储（配合日志文件）

### 数据库故障

#### 事务故障

- 非预期、不正常的程序结束造成
- 事务撤销 UNDO

#### 系统故障

- 所有运行中事务均非正常结束
- 原因：硬件错误/OS错误
- 事务的重做或撤销（区分于是否已经commit）

#### 介质故障 Media Failure

辅助存储器介质遭到破坏

## 六 数据库设计

### 设计的内容

- 结构设计
  - 静态模型，各应用程序共享
  - 概念 逻辑 物理
- 行为设计
  - 设计应用程序

### 设计步骤

阶段|内容|工作
--|--|--
系统需求分析||数据流图与数据字典
概念结构设计||E-R图
逻辑结构设计|具体到某个DBMS|
物理设计|存储结构与存取方法|建表
数据库实施||装入原始数据
运行与维护||

### ER图

成分|图形|标注
--|--|--
实体|矩形框|
属性|椭圆形|
联系|菱形|

类型，如m:n，分别标在联系与实体相连的两条无向边上